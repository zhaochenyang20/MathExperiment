


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>scipy.optimize.least_squares &#8212; SciPy v1.10.0 Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/scipy.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/design-tabs.js"></script>
    <script src="../../_static/versioncheck.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="scipy.optimize.nnls" href="scipy.optimize.nnls.html" />
    <link rel="prev" title="scipy.optimize.direct" href="scipy.optimize.direct.html" />
    <script defer data-domain="docs.scipy.org" src="https://views.scientific-python.org/js/script.js"></script>
    
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">

  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
    <img src="../../_static/logo.svg" class="logo__image only-light" alt="Logo image">
    <img src="../../_static/logo.svg" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../getting_started.html">
  Getting started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../tutorial/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="../index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../dev/index.html">
  Development
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../release.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        1.10.0  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables reference/generated/scipy.optimize.least_squares and {'json_url': 'https://scipy.github.io/devdocs/_static/version_switcher.json', 'version_match': '1.10.0'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "reference/generated/scipy.optimize.least_squares.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://scipy.github.io/devdocs/_static/version_switcher.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "reference/generated/scipy.optimize.least_squares.html";
        let btn = document.getElementById("version_switcher_button");
        // Set empty strings by default so that these attributes exist and can be used in CSS selectors
        btn.dataset["activeVersionName"] = "";
        btn.dataset["activeVersion"] = "";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 1.10.0 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "1.10.0") {
                node.classList.add("active");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/scipy/scipy" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/SciPy_team" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../cluster.html">
   Clustering package (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.cluster
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../cluster.vq.html">
   K-means clustering and vector quantization (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.cluster.vq
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../cluster.hierarchy.html">
   Hierarchical clustering (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.cluster.hierarchy
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../constants.html">
   Constants (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.constants
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../datasets.html">
   Datasets (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.datasets
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fft.html">
   Discrete Fourier transforms (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.fft
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fftpack.html">
   Legacy discrete Fourier transforms (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.fftpack
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../integrate.html">
   Integration and ODEs (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.integrate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../interpolate.html">
   Interpolation (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.interpolate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../io.html">
   Input and output (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.io
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.html">
   Linear algebra (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.linalg
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.blas.html">
   Low-level BLAS functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.linalg.blas
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.lapack.html">
   Low-level LAPACK functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.linalg.lapack
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.cython_blas.html">
   BLAS Functions for Cython
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.cython_lapack.html">
   LAPACK functions for Cython
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.interpolative.html">
   Interpolative matrix decomposition (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.linalg.interpolative
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../misc.html">
   Miscellaneous routines (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.misc
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ndimage.html">
   Multidimensional image processing (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.ndimage
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../odr.html">
   Orthogonal distance regression (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.odr
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="../optimize.html">
   Optimization and root finding (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.optimize
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../optimize.cython_optimize.html">
   Cython optimize zeros API
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../signal.html">
   Signal processing (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.signal
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sparse.html">
   Sparse matrices (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.sparse
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sparse.linalg.html">
   Sparse linear algebra (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.sparse.linalg
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sparse.csgraph.html">
   Compressed sparse graph routines (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.sparse.csgraph
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../spatial.html">
   Spatial algorithms and data structures (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.spatial
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../spatial.distance.html">
   Distance computations (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.spatial.distance
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../special.html">
   Special functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.special
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../stats.html">
   Statistical functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.stats
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../stats._result_classes.html">
   Result classes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../stats.contingency.html">
   Contingency table functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.stats.contingency
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../stats.mstats.html">
   Statistical functions for masked arrays (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.stats.mstats
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../stats.qmc.html">
   Quasi-Monte Carlo submodule (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.stats.qmc
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../stats.sampling.html">
   Random Number Generators (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.stats.sampling
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ccallback.html">
   Low-level callback functions
  </a>
 </li>
</ul>

    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#scipy.optimize.least_squares">
   <code class="docutils literal notranslate">
    <span class="pre">
     least_squares
    </span>
   </code>
  </a>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      
    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="scipy-optimize-least-squares">
<h1>scipy.optimize.least_squares<a class="headerlink" href="#scipy-optimize-least-squares" title="Permalink to this heading">#</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="scipy.optimize.least_squares">
<span class="sig-prename descclassname"><span class="pre">scipy.optimize.</span></span><span class="sig-name descname"><span class="pre">least_squares</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2-point'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(-inf,</span> <span class="pre">inf)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'trf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ftol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr_solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac_sparsity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scipy/scipy/blob/v1.10.0/scipy/optimize/_lsq/least_squares.py#L241-L963"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scipy.optimize.least_squares" title="Permalink to this definition">#</a></dt>
<dd><p>Solve a nonlinear least-squares problem with bounds on the variables.</p>
<p>Given the residuals f(x) (an m-D real function of n real
variables) and the loss function rho(s) (a scalar function), <a class="reference internal" href="#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-obj docutils literal notranslate"><span class="pre">least_squares</span></code></a>
finds a local minimum of the cost function F(x):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">minimize</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rho</span><span class="p">(</span><span class="n">f_i</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">subject</span> <span class="n">to</span> <span class="n">lb</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">ub</span>
</pre></div>
</div>
<p>The purpose of the loss function rho(s) is to reduce the influence of
outliers on the solution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>fun</strong><span class="classifier">callable</span></dt><dd><p>Function which computes the vector of residuals, with the signature
<code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>, i.e., the minimization proceeds with
respect to its first argument. The argument <code class="docutils literal notranslate"><span class="pre">x</span></code> passed to this
function is an ndarray of shape (n,) (never a scalar, even for n=1).
It must allocate and return a 1-D array_like of shape (m,) or a scalar.
If the argument <code class="docutils literal notranslate"><span class="pre">x</span></code> is complex or the function <code class="docutils literal notranslate"><span class="pre">fun</span></code> returns
complex residuals, it must be wrapped in a real function of real
arguments, as shown at the end of the Examples section.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">array_like with shape (n,) or float</span></dt><dd><p>Initial guess on independent variables. If float, it will be treated
as a 1-D array with one element.</p>
</dd>
<dt><strong>jac</strong><span class="classifier">{‘2-point’, ‘3-point’, ‘cs’, callable}, optional</span></dt><dd><p>Method of computing the Jacobian matrix (an m-by-n matrix, where
element (i, j) is the partial derivative of f[i] with respect to
x[j]). The keywords select a finite difference scheme for numerical
estimation. The scheme ‘3-point’ is more accurate, but requires
twice as many operations as ‘2-point’ (default). The scheme ‘cs’
uses complex steps, and while potentially the most accurate, it is
applicable only when <em class="xref py py-obj">fun</em> correctly handles complex inputs and
can be analytically continued to the complex plane. Method ‘lm’
always uses the ‘2-point’ scheme. If callable, it is used as
<code class="docutils literal notranslate"><span class="pre">jac(x,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> and should return a good approximation
(or the exact value) for the Jacobian as an array_like (np.atleast_2d
is applied), a sparse matrix (csr_matrix preferred for performance) or
a <a class="reference internal" href="scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator" title="scipy.sparse.linalg.LinearOperator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.LinearOperator</span></code></a>.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">2-tuple of array_like or <a class="reference internal" href="scipy.optimize.Bounds.html#scipy.optimize.Bounds" title="scipy.optimize.Bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Bounds</span></code></a>, optional</span></dt><dd><p>There are two ways to specify bounds:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Instance of <a class="reference internal" href="scipy.optimize.Bounds.html#scipy.optimize.Bounds" title="scipy.optimize.Bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Bounds</span></code></a> class</p></li>
<li><p>Lower and upper bounds on independent variables. Defaults to no
bounds. Each array must match the size of <em class="xref py py-obj">x0</em> or be a scalar,
in the latter case a bound will be the same for all variables.
Use <code class="docutils literal notranslate"><span class="pre">np.inf</span></code> with an appropriate sign to disable bounds on all
or some variables.</p></li>
</ol>
</div></blockquote>
</dd>
<dt><strong>method</strong><span class="classifier">{‘trf’, ‘dogbox’, ‘lm’}, optional</span></dt><dd><p>Algorithm to perform minimization.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘trf’ : Trust Region Reflective algorithm, particularly suitable
for large sparse problems with bounds. Generally robust method.</p></li>
<li><p>‘dogbox’ : dogleg algorithm with rectangular trust regions,
typical use case is small problems with bounds. Not recommended
for problems with rank-deficient Jacobian.</p></li>
<li><p>‘lm’ : Levenberg-Marquardt algorithm as implemented in MINPACK.
Doesn’t handle bounds and sparse Jacobians. Usually the most
efficient method for small unconstrained problems.</p></li>
</ul>
</div></blockquote>
<p>Default is ‘trf’. See Notes for more information.</p>
</dd>
<dt><strong>ftol</strong><span class="classifier">float or None, optional</span></dt><dd><p>Tolerance for termination by the change of the cost function. Default
is 1e-8. The optimization process is stopped when <code class="docutils literal notranslate"><span class="pre">dF</span> <span class="pre">&lt;</span> <span class="pre">ftol</span> <span class="pre">*</span> <span class="pre">F</span></code>,
and there was an adequate agreement between a local quadratic model and
the true model in the last step.</p>
<p>If None and ‘method’ is not ‘lm’, the termination by this condition is
disabled. If ‘method’ is ‘lm’, this tolerance must be higher than
machine epsilon.</p>
</dd>
<dt><strong>xtol</strong><span class="classifier">float or None, optional</span></dt><dd><p>Tolerance for termination by the change of the independent variables.
Default is 1e-8. The exact condition depends on the <em class="xref py py-obj">method</em> used:</p>
<blockquote>
<div><ul class="simple">
<li><p>For ‘trf’ and ‘dogbox’ : <code class="docutils literal notranslate"><span class="pre">norm(dx)</span> <span class="pre">&lt;</span> <span class="pre">xtol</span> <span class="pre">*</span> <span class="pre">(xtol</span> <span class="pre">+</span> <span class="pre">norm(x))</span></code>.</p></li>
<li><p>For ‘lm’ : <code class="docutils literal notranslate"><span class="pre">Delta</span> <span class="pre">&lt;</span> <span class="pre">xtol</span> <span class="pre">*</span> <span class="pre">norm(xs)</span></code>, where <code class="docutils literal notranslate"><span class="pre">Delta</span></code> is
a trust-region radius and <code class="docutils literal notranslate"><span class="pre">xs</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">x</span></code>
scaled according to <em class="xref py py-obj">x_scale</em> parameter (see below).</p></li>
</ul>
</div></blockquote>
<p>If None and ‘method’ is not ‘lm’, the termination by this condition is
disabled. If ‘method’ is ‘lm’, this tolerance must be higher than
machine epsilon.</p>
</dd>
<dt><strong>gtol</strong><span class="classifier">float or None, optional</span></dt><dd><p>Tolerance for termination by the norm of the gradient. Default is 1e-8.
The exact condition depends on a <em class="xref py py-obj">method</em> used:</p>
<blockquote>
<div><ul class="simple">
<li><p>For ‘trf’ : <code class="docutils literal notranslate"><span class="pre">norm(g_scaled,</span> <span class="pre">ord=np.inf)</span> <span class="pre">&lt;</span> <span class="pre">gtol</span></code>, where
<code class="docutils literal notranslate"><span class="pre">g_scaled</span></code> is the value of the gradient scaled to account for
the presence of the bounds <a class="reference internal" href="#r20fc1df64af7-stir" id="id1">[STIR]</a>.</p></li>
<li><p>For ‘dogbox’ : <code class="docutils literal notranslate"><span class="pre">norm(g_free,</span> <span class="pre">ord=np.inf)</span> <span class="pre">&lt;</span> <span class="pre">gtol</span></code>, where
<code class="docutils literal notranslate"><span class="pre">g_free</span></code> is the gradient with respect to the variables which
are not in the optimal state on the boundary.</p></li>
<li><p>For ‘lm’ : the maximum absolute value of the cosine of angles
between columns of the Jacobian and the residual vector is less
than <em class="xref py py-obj">gtol</em>, or the residual vector is zero.</p></li>
</ul>
</div></blockquote>
<p>If None and ‘method’ is not ‘lm’, the termination by this condition is
disabled. If ‘method’ is ‘lm’, this tolerance must be higher than
machine epsilon.</p>
</dd>
<dt><strong>x_scale</strong><span class="classifier">array_like or ‘jac’, optional</span></dt><dd><p>Characteristic scale of each variable. Setting <em class="xref py py-obj">x_scale</em> is equivalent
to reformulating the problem in scaled variables <code class="docutils literal notranslate"><span class="pre">xs</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">/</span> <span class="pre">x_scale</span></code>.
An alternative view is that the size of a trust region along jth
dimension is proportional to <code class="docutils literal notranslate"><span class="pre">x_scale[j]</span></code>. Improved convergence may
be achieved by setting <em class="xref py py-obj">x_scale</em> such that a step of a given size
along any of the scaled variables has a similar effect on the cost
function. If set to ‘jac’, the scale is iteratively updated using the
inverse norms of the columns of the Jacobian matrix (as described in
<a class="reference internal" href="#r20fc1df64af7-jjmore" id="id2">[JJMore]</a>).</p>
</dd>
<dt><strong>loss</strong><span class="classifier">str or callable, optional</span></dt><dd><p>Determines the loss function. The following keyword values are allowed:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘linear’ (default) : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">z</span></code>. Gives a standard
least-squares problem.</p></li>
<li><p>‘soft_l1’ : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">((1</span> <span class="pre">+</span> <span class="pre">z)**0.5</span> <span class="pre">-</span> <span class="pre">1)</span></code>. The smooth
approximation of l1 (absolute value) loss. Usually a good
choice for robust least squares.</p></li>
<li><p>‘huber’ : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">z</span> <span class="pre">if</span> <span class="pre">z</span> <span class="pre">&lt;=</span> <span class="pre">1</span> <span class="pre">else</span> <span class="pre">2*z**0.5</span> <span class="pre">-</span> <span class="pre">1</span></code>. Works
similarly to ‘soft_l1’.</p></li>
<li><p>‘cauchy’ : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">ln(1</span> <span class="pre">+</span> <span class="pre">z)</span></code>. Severely weakens outliers
influence, but may cause difficulties in optimization process.</p></li>
<li><p>‘arctan’ : <code class="docutils literal notranslate"><span class="pre">rho(z)</span> <span class="pre">=</span> <span class="pre">arctan(z)</span></code>. Limits a maximum loss on
a single residual, has properties similar to ‘cauchy’.</p></li>
</ul>
</div></blockquote>
<p>If callable, it must take a 1-D ndarray <code class="docutils literal notranslate"><span class="pre">z=f**2</span></code> and return an
array_like with shape (3, m) where row 0 contains function values,
row 1 contains first derivatives and row 2 contains second
derivatives. Method ‘lm’ supports only ‘linear’ loss.</p>
</dd>
<dt><strong>f_scale</strong><span class="classifier">float, optional</span></dt><dd><p>Value of soft margin between inlier and outlier residuals, default
is 1.0. The loss function is evaluated as follows
<code class="docutils literal notranslate"><span class="pre">rho_(f**2)</span> <span class="pre">=</span> <span class="pre">C**2</span> <span class="pre">*</span> <span class="pre">rho(f**2</span> <span class="pre">/</span> <span class="pre">C**2)</span></code>, where <code class="docutils literal notranslate"><span class="pre">C</span></code> is <em class="xref py py-obj">f_scale</em>,
and <code class="docutils literal notranslate"><span class="pre">rho</span></code> is determined by <em class="xref py py-obj">loss</em> parameter. This parameter has
no effect with <code class="docutils literal notranslate"><span class="pre">loss='linear'</span></code>, but for other <em class="xref py py-obj">loss</em> values it is
of crucial importance.</p>
</dd>
<dt><strong>max_nfev</strong><span class="classifier">None or int, optional</span></dt><dd><p>Maximum number of function evaluations before the termination.
If None (default), the value is chosen automatically:</p>
<blockquote>
<div><ul class="simple">
<li><p>For ‘trf’ and ‘dogbox’ : 100 * n.</p></li>
<li><p>For ‘lm’ :  100 * n if <em class="xref py py-obj">jac</em> is callable and 100 * n * (n + 1)
otherwise (because ‘lm’ counts function calls in Jacobian
estimation).</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>diff_step</strong><span class="classifier">None or array_like, optional</span></dt><dd><p>Determines the relative step size for the finite difference
approximation of the Jacobian. The actual step is computed as
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">diff_step</span></code>. If None (default), then <em class="xref py py-obj">diff_step</em> is taken to be
a conventional “optimal” power of machine epsilon for the finite
difference scheme used <a class="reference internal" href="#r20fc1df64af7-nr" id="id3">[NR]</a>.</p>
</dd>
<dt><strong>tr_solver</strong><span class="classifier">{None, ‘exact’, ‘lsmr’}, optional</span></dt><dd><p>Method for solving trust-region subproblems, relevant only for ‘trf’
and ‘dogbox’ methods.</p>
<blockquote>
<div><ul class="simple">
<li><p>‘exact’ is suitable for not very large problems with dense
Jacobian matrices. The computational complexity per iteration is
comparable to a singular value decomposition of the Jacobian
matrix.</p></li>
<li><p>‘lsmr’ is suitable for problems with sparse and large Jacobian
matrices. It uses the iterative procedure
<a class="reference internal" href="scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr" title="scipy.sparse.linalg.lsmr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.lsmr</span></code></a> for finding a solution of a linear
least-squares problem and only requires matrix-vector product
evaluations.</p></li>
</ul>
</div></blockquote>
<p>If None (default), the solver is chosen based on the type of Jacobian
returned on the first iteration.</p>
</dd>
<dt><strong>tr_options</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword options passed to trust-region solver.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tr_solver='exact'</span></code>: <em class="xref py py-obj">tr_options</em> are ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tr_solver='lsmr'</span></code>: options for <a class="reference internal" href="scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr" title="scipy.sparse.linalg.lsmr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.lsmr</span></code></a>.
Additionally,  <code class="docutils literal notranslate"><span class="pre">method='trf'</span></code> supports  ‘regularize’ option
(bool, default is True), which adds a regularization term to the
normal equation, which improves convergence if the Jacobian is
rank-deficient <a class="reference internal" href="#r20fc1df64af7-byrd" id="id4">[Byrd]</a> (eq. 3.4).</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>jac_sparsity</strong><span class="classifier">{None, array_like, sparse matrix}, optional</span></dt><dd><p>Defines the sparsity structure of the Jacobian matrix for finite
difference estimation, its shape must be (m, n). If the Jacobian has
only few non-zero elements in <em>each</em> row, providing the sparsity
structure will greatly speed up the computations <a class="reference internal" href="#r20fc1df64af7-curtis" id="id5">[Curtis]</a>. A zero
entry means that a corresponding element in the Jacobian is identically
zero. If provided, forces the use of ‘lsmr’ trust-region solver.
If None (default), then dense differencing will be used. Has no effect
for ‘lm’ method.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">{0, 1, 2}, optional</span></dt><dd><p>Level of algorithm’s verbosity:</p>
<blockquote>
<div><ul class="simple">
<li><p>0 (default) : work silently.</p></li>
<li><p>1 : display a termination report.</p></li>
<li><p>2 : display progress during iterations (not supported by ‘lm’
method).</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>args, kwargs</strong><span class="classifier">tuple and dict, optional</span></dt><dd><p>Additional arguments passed to <em class="xref py py-obj">fun</em> and <em class="xref py py-obj">jac</em>. Both empty by default.
The calling signature is <code class="docutils literal notranslate"><span class="pre">fun(x,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> and the same for
<em class="xref py py-obj">jac</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">OptimizeResult</span></dt><dd><p><a class="reference internal" href="scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult" title="scipy.optimize.OptimizeResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OptimizeResult</span></code></a> with the following fields defined:</p>
<blockquote>
<div><dl>
<dt>x<span class="classifier">ndarray, shape (n,)</span></dt><dd><p>Solution found.</p>
</dd>
<dt>cost<span class="classifier">float</span></dt><dd><p>Value of the cost function at the solution.</p>
</dd>
<dt>fun<span class="classifier">ndarray, shape (m,)</span></dt><dd><p>Vector of residuals at the solution.</p>
</dd>
<dt>jac<span class="classifier">ndarray, sparse matrix or LinearOperator, shape (m, n)</span></dt><dd><p>Modified Jacobian matrix at the solution, in the sense that J^T J
is a Gauss-Newton approximation of the Hessian of the cost function.
The type is the same as the one used by the algorithm.</p>
</dd>
<dt>grad<span class="classifier">ndarray, shape (m,)</span></dt><dd><p>Gradient of the cost function at the solution.</p>
</dd>
<dt>optimality<span class="classifier">float</span></dt><dd><p>First-order optimality measure. In unconstrained problems, it is
always the uniform norm of the gradient. In constrained problems,
it is the quantity which was compared with <em class="xref py py-obj">gtol</em> during iterations.</p>
</dd>
<dt>active_mask<span class="classifier">ndarray of int, shape (n,)</span></dt><dd><p>Each component shows whether a corresponding constraint is active
(that is, whether a variable is at the bound):</p>
<blockquote>
<div><ul class="simple">
<li><p>0 : a constraint is not active.</p></li>
<li><p>-1 : a lower bound is active.</p></li>
<li><p>1 : an upper bound is active.</p></li>
</ul>
</div></blockquote>
<p>Might be somewhat arbitrary for ‘trf’ method as it generates a
sequence of strictly feasible iterates and <em class="xref py py-obj">active_mask</em> is
determined within a tolerance threshold.</p>
</dd>
<dt>nfev<span class="classifier">int</span></dt><dd><p>Number of function evaluations done. Methods ‘trf’ and ‘dogbox’ do
not count function calls for numerical Jacobian approximation, as
opposed to ‘lm’ method.</p>
</dd>
<dt>njev<span class="classifier">int or None</span></dt><dd><p>Number of Jacobian evaluations done. If numerical Jacobian
approximation is used in ‘lm’ method, it is set to None.</p>
</dd>
<dt>status<span class="classifier">int</span></dt><dd><p>The reason for algorithm termination:</p>
<blockquote>
<div><ul class="simple">
<li><p>-1 : improper input parameters status returned from MINPACK.</p></li>
<li><p>0 : the maximum number of function evaluations is exceeded.</p></li>
<li><p>1 : <em class="xref py py-obj">gtol</em> termination condition is satisfied.</p></li>
<li><p>2 : <em class="xref py py-obj">ftol</em> termination condition is satisfied.</p></li>
<li><p>3 : <em class="xref py py-obj">xtol</em> termination condition is satisfied.</p></li>
<li><p>4 : Both <em class="xref py py-obj">ftol</em> and <em class="xref py py-obj">xtol</em> termination conditions are satisfied.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>message<span class="classifier">str</span></dt><dd><p>Verbal description of the termination reason.</p>
</dd>
<dt>success<span class="classifier">bool</span></dt><dd><p>True if one of the convergence criteria is satisfied (<em class="xref py py-obj">status</em> &gt; 0).</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="scipy.optimize.leastsq.html#scipy.optimize.leastsq" title="scipy.optimize.leastsq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">leastsq</span></code></a></dt><dd><p>A legacy wrapper for the MINPACK implementation of the Levenberg-Marquadt algorithm.</p>
</dd>
<dt><a class="reference internal" href="scipy.optimize.curve_fit.html#scipy.optimize.curve_fit" title="scipy.optimize.curve_fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">curve_fit</span></code></a></dt><dd><p>Least-squares minimization applied to a curve-fitting problem.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Method ‘lm’ (Levenberg-Marquardt) calls a wrapper over least-squares
algorithms implemented in MINPACK (lmder, lmdif). It runs the
Levenberg-Marquardt algorithm formulated as a trust-region type algorithm.
The implementation is based on paper <a class="reference internal" href="#r20fc1df64af7-jjmore" id="id6">[JJMore]</a>, it is very robust and
efficient with a lot of smart tricks. It should be your first choice
for unconstrained problems. Note that it doesn’t support bounds. Also,
it doesn’t work when m &lt; n.</p>
<p>Method ‘trf’ (Trust Region Reflective) is motivated by the process of
solving a system of equations, which constitute the first-order optimality
condition for a bound-constrained minimization problem as formulated in
<a class="reference internal" href="#r20fc1df64af7-stir" id="id7">[STIR]</a>. The algorithm iteratively solves trust-region subproblems
augmented by a special diagonal quadratic term and with trust-region shape
determined by the distance from the bounds and the direction of the
gradient. This enhancements help to avoid making steps directly into bounds
and efficiently explore the whole space of variables. To further improve
convergence, the algorithm considers search directions reflected from the
bounds. To obey theoretical requirements, the algorithm keeps iterates
strictly feasible. With dense Jacobians trust-region subproblems are
solved by an exact method very similar to the one described in <a class="reference internal" href="#r20fc1df64af7-jjmore" id="id8">[JJMore]</a>
(and implemented in MINPACK). The difference from the MINPACK
implementation is that a singular value decomposition of a Jacobian
matrix is done once per iteration, instead of a QR decomposition and series
of Givens rotation eliminations. For large sparse Jacobians a 2-D subspace
approach of solving trust-region subproblems is used <a class="reference internal" href="#r20fc1df64af7-stir" id="id9">[STIR]</a>, <a class="reference internal" href="#r20fc1df64af7-byrd" id="id10">[Byrd]</a>.
The subspace is spanned by a scaled gradient and an approximate
Gauss-Newton solution delivered by <a class="reference internal" href="scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr" title="scipy.sparse.linalg.lsmr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.lsmr</span></code></a>. When no
constraints are imposed the algorithm is very similar to MINPACK and has
generally comparable performance. The algorithm works quite robust in
unbounded and bounded problems, thus it is chosen as a default algorithm.</p>
<p>Method ‘dogbox’ operates in a trust-region framework, but considers
rectangular trust regions as opposed to conventional ellipsoids <a class="reference internal" href="#r20fc1df64af7-voglis" id="id11">[Voglis]</a>.
The intersection of a current trust region and initial bounds is again
rectangular, so on each iteration a quadratic minimization problem subject
to bound constraints is solved approximately by Powell’s dogleg method
<a class="reference internal" href="#r20fc1df64af7-numopt" id="id12">[NumOpt]</a>. The required Gauss-Newton step can be computed exactly for
dense Jacobians or approximately by <a class="reference internal" href="scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr" title="scipy.sparse.linalg.lsmr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.lsmr</span></code></a> for large
sparse Jacobians. The algorithm is likely to exhibit slow convergence when
the rank of Jacobian is less than the number of variables. The algorithm
often outperforms ‘trf’ in bounded problems with a small number of
variables.</p>
<p>Robust loss functions are implemented as described in <a class="reference internal" href="#r20fc1df64af7-ba" id="id13">[BA]</a>. The idea
is to modify a residual vector and a Jacobian matrix on each iteration
such that computed gradient and Gauss-Newton Hessian approximation match
the true gradient and Hessian approximation of the cost function. Then
the algorithm proceeds in a normal way, i.e., robust loss functions are
implemented as a simple wrapper over standard least-squares algorithms.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17.0.</span></p>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r20fc1df64af7-stir" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>STIR<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id7">2</a>,<a role="doc-backlink" href="#id9">3</a>)</span>
<p>M. A. Branch, T. F. Coleman, and Y. Li, “A Subspace, Interior,
and Conjugate Gradient Method for Large-Scale Bound-Constrained
Minimization Problems,” SIAM Journal on Scientific Computing,
Vol. 21, Number 1, pp 1-23, 1999.</p>
</div>
<div class="citation" id="r20fc1df64af7-nr" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">NR</a><span class="fn-bracket">]</span></span>
<p>William H. Press et. al., “Numerical Recipes. The Art of Scientific
Computing. 3rd edition”, Sec. 5.7.</p>
</div>
<div class="citation" id="r20fc1df64af7-byrd" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Byrd<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id4">1</a>,<a role="doc-backlink" href="#id10">2</a>)</span>
<p>R. H. Byrd, R. B. Schnabel and G. A. Shultz, “Approximate
solution of the trust region problem by minimization over
two-dimensional subspaces”, Math. Programming, 40, pp. 247-263,
1988.</p>
</div>
<div class="citation" id="r20fc1df64af7-curtis" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">Curtis</a><span class="fn-bracket">]</span></span>
<p>A. Curtis, M. J. D. Powell, and J. Reid, “On the estimation of
sparse Jacobian matrices”, Journal of the Institute of
Mathematics and its Applications, 13, pp. 117-120, 1974.</p>
</div>
<div class="citation" id="r20fc1df64af7-jjmore" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>JJMore<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id6">2</a>,<a role="doc-backlink" href="#id8">3</a>)</span>
<p>J. J. More, “The Levenberg-Marquardt Algorithm: Implementation
and Theory,” Numerical Analysis, ed. G. A. Watson, Lecture
Notes in Mathematics 630, Springer Verlag, pp. 105-116, 1977.</p>
</div>
<div class="citation" id="r20fc1df64af7-voglis" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">Voglis</a><span class="fn-bracket">]</span></span>
<p>C. Voglis and I. E. Lagaris, “A Rectangular Trust Region
Dogleg Approach for Unconstrained and Bound Constrained
Nonlinear Optimization”, WSEAS International Conference on
Applied Mathematics, Corfu, Greece, 2004.</p>
</div>
<div class="citation" id="r20fc1df64af7-numopt" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">NumOpt</a><span class="fn-bracket">]</span></span>
<p>J. Nocedal and S. J. Wright, “Numerical optimization,
2nd edition”, Chapter 4.</p>
</div>
<div class="citation" id="r20fc1df64af7-ba" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">BA</a><span class="fn-bracket">]</span></span>
<p>B. Triggs et. al., “Bundle Adjustment - A Modern Synthesis”,
Proceedings of the International Workshop on Vision Algorithms:
Theory and Practice, pp. 298-372, 1999.</p>
</div>
</div>
<p class="rubric">Examples</p>
<p>In this example we find a minimum of the Rosenbrock function without bounds
on independent variables.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun_rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
</pre></div>
</div>
<p>Notice that we only provide the vector of the residuals. The algorithm
constructs the cost function as a sum of squares of the residuals, which
gives the Rosenbrock function. The exact minimum is at <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[1.0,</span> <span class="pre">1.0]</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">least_squares</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0_rosenbrock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun_rosenbrock</span><span class="p">,</span> <span class="n">x0_rosenbrock</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span><span class="o">.</span><span class="n">cost</span>
<span class="go">9.8669242910846867e-30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_1</span><span class="o">.</span><span class="n">optimality</span>
<span class="go">8.8928864934219529e-14</span>
</pre></div>
</div>
<p>We now constrain the variables, in such a way that the previous solution
becomes infeasible. Specifically, we require that <code class="docutils literal notranslate"><span class="pre">x[1]</span> <span class="pre">&gt;=</span> <span class="pre">1.5</span></code>, and
<code class="docutils literal notranslate"><span class="pre">x[0]</span></code> left unconstrained. To this end, we specify the <em class="xref py py-obj">bounds</em> parameter
to <a class="reference internal" href="#scipy.optimize.least_squares" title="scipy.optimize.least_squares"><code class="xref py py-obj docutils literal notranslate"><span class="pre">least_squares</span></code></a> in the form <code class="docutils literal notranslate"><span class="pre">bounds=([-np.inf,</span> <span class="pre">1.5],</span> <span class="pre">np.inf)</span></code>.</p>
<p>We also provide the analytic Jacobian:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">jac_rosenbrock</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span>        <span class="p">[</span><span class="o">-</span><span class="mi">20</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">10</span><span class="p">],</span>
<span class="gp">... </span>        <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>Putting this all together, we see that the new solution lies on the bound:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun_rosenbrock</span><span class="p">,</span> <span class="n">x0_rosenbrock</span><span class="p">,</span> <span class="n">jac_rosenbrock</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span><span class="o">.</span><span class="n">x</span>
<span class="go">array([ 1.22437075,  1.5       ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span><span class="o">.</span><span class="n">cost</span>
<span class="go">0.025213093946805685</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_2</span><span class="o">.</span><span class="n">optimality</span>
<span class="go">1.5885401433157753e-07</span>
</pre></div>
</div>
<p>Now we solve a system of equations (i.e., the cost function should be zero
at a minimum) for a Broyden tridiagonal vector-valued function of 100000
variables:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun_broyden</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">f</span>
</pre></div>
</div>
<p>The corresponding Jacobian matrix is sparse. We tell the algorithm to
estimate it by finite differences and provide the sparsity structure of
Jacobian to significantly speed up this process.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">lil_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sparsity_broyden</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">sparsity</span> <span class="o">=</span> <span class="n">lil_matrix</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sparsity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sparsity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sparsity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">sparsity</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0_broyden</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_3</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun_broyden</span><span class="p">,</span> <span class="n">x0_broyden</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">jac_sparsity</span><span class="o">=</span><span class="n">sparsity_broyden</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_3</span><span class="o">.</span><span class="n">cost</span>
<span class="go">4.5687069299604613e-23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_3</span><span class="o">.</span><span class="n">optimality</span>
<span class="go">1.1650454296851518e-11</span>
</pre></div>
</div>
<p>Let’s also solve a curve fitting problem using robust loss function to
take care of outliers in the data. Define the model function as
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">*</span> <span class="pre">exp(c</span> <span class="pre">*</span> <span class="pre">t)</span></code>, where t is a predictor variable, y is an
observation and a, b, c are parameters to estimate.</p>
<p>First, define the function which generates the data with noise and
outliers, define the model parameters, and generate data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">default_rng</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen_data</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">n_outliers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">rng</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">y</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">error</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">outliers</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n_outliers</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">error</span><span class="p">[</span><span class="n">outliers</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">10</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">y</span> <span class="o">+</span> <span class="n">error</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_min</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_max</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_points</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_train</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">n_outliers</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Define function for computing residuals and initial estimate of
parameters.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
</pre></div>
</div>
<p>Compute a standard least-squares solution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_lsq</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>
</pre></div>
</div>
<p>Now compute two solutions with two different robust loss functions. The
parameter <em class="xref py py-obj">f_scale</em> is set to 0.1, meaning that inlier residuals should
not significantly exceed 0.1 (the noise level used).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res_soft_l1</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;soft_l1&#39;</span><span class="p">,</span> <span class="n">f_scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_log</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;cauchy&#39;</span><span class="p">,</span> <span class="n">f_scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">))</span>
</pre></div>
</div>
<p>And, finally, plot all the curves. We see that by selecting an appropriate
<em class="xref py py-obj">loss</em>  we can get estimates close to optimal even in the presence of
strong outliers. But keep in mind that generally it is recommended to try
‘soft_l1’ or ‘huber’ losses first (if at all necessary) as the other two
options may cause difficulties in optimization process.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">n_points</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_true</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_lsq</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="o">*</span><span class="n">res_lsq</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_soft_l1</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="o">*</span><span class="n">res_soft_l1</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_log</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="o">*</span><span class="n">res_log</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_lsq</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;linear loss&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_soft_l1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;soft_l1 loss&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_test</span><span class="p">,</span> <span class="n">y_log</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;cauchy loss&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../../_images/scipy-optimize-least_squares-1_00_00.png" class="plot-directive" src="../../_images/scipy-optimize-least_squares-1_00_00.png" />
</figure>
<p>In the next example, we show how complex-valued residual functions of
complex variables can be optimized with <code class="docutils literal notranslate"><span class="pre">least_squares()</span></code>. Consider the
following function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">z</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>We wrap it into a function of real variables that returns real residuals
by simply handling the real and imaginary parts as independent variables:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f_wrap</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">fx</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fx</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">imag</span><span class="p">])</span>
</pre></div>
</div>
<p>Thus, instead of the original m-D complex function of n complex
variables we optimize a 2m-D real function of 2n real variables:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">least_squares</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_wrapped</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">f_wrap</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">res_wrapped</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">res_wrapped</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span>
<span class="go">(0.49999999999925893+0.49999999999925893j)</span>
</pre></div>
</div>
</dd></dl>

</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="scipy.optimize.direct.html" title="previous page">
      <i class="fas fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">scipy.optimize.direct</p>
      </div>
  </a>
  <a class='right-next' id="next-link" href="scipy.optimize.nnls.html" title="next page">
  <div class="prev-next-info">
      <p class="prev-next-subtitle">next</p>
      <p class="prev-next-title">scipy.optimize.nnls</p>
  </div>
  <i class="fas fa-angle-right"></i>
  </a>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2008-2023, The SciPy community.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>