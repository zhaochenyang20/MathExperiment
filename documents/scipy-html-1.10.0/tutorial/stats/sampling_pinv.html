


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Polynomial interpolation based INVersion of CDF (PINV) &#8212; SciPy v1.10.0 Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/scipy.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/design-tabs.js"></script>
    <script async="async" src="../../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script src="../../_static/versioncheck.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Discrete Guide Table (DGT)" href="sampling_dgt.html" />
    <link rel="prev" title="Discrete Alias Urn (DAU)" href="sampling_dau.html" />
    <script defer data-domain="docs.scipy.org" src="https://views.scientific-python.org/js/script.js"></script>
    
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">

  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
    <img src="../../_static/logo.svg" class="logo__image only-light" alt="Logo image">
    <img src="../../_static/logo.svg" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../getting_started.html">
  Getting started
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="../index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../dev/index.html">
  Development
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../release.html">
  Release notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        1.10.0  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables tutorial/stats/sampling_pinv and {'json_url': 'https://scipy.github.io/devdocs/_static/version_switcher.json', 'version_match': '1.10.0'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "tutorial/stats/sampling_pinv.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://scipy.github.io/devdocs/_static/version_switcher.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "tutorial/stats/sampling_pinv.html";
        let btn = document.getElementById("version_switcher_button");
        // Set empty strings by default so that these attributes exist and can be used in CSS selectors
        btn.dataset["activeVersionName"] = "";
        btn.dataset["activeVersion"] = "";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 1.10.0 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "1.10.0") {
                node.classList.add("active");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/scipy/scipy" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/SciPy_team" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../general.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../special.html">
   Special functions (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.special
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../integrate.html">
   Integration (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.integrate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../optimize.html">
   Optimization (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.optimize
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../interpolate.html">
   Interpolation (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.interpolate
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fft.html">
   Fourier Transforms (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.fft
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../signal.html">
   Signal Processing (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.signal
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../linalg.html">
   Linear Algebra (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.linalg
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../arpack.html">
   Sparse eigenvalue problems with ARPACK
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../csgraph.html">
   Compressed Sparse Graph Routines (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.sparse.csgraph
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../spatial.html">
   Spatial data structures and algorithms (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.spatial
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../stats.html">
   Statistics (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.stats
    </span>
   </code>
   )
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="discrete.html">
     Discrete Statistical Distributions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="continuous.html">
     Continuous Statistical Distributions
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="reference internal" href="sampling.html">
     Universal Non-Uniform Random Number Sampling in SciPy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="resampling.html">
     Resampling and Monte Carlo Methods
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ndimage.html">
   Multidimensional image processing (
   <code class="xref py py-obj docutils literal notranslate">
    <span class="pre">
     scipy.ndimage
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../io.html">
   File IO (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     scipy.io
    </span>
   </code>
   )
  </a>
 </li>
</ul>

    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      
    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="polynomial-interpolation-based-inversion-of-cdf-pinv">
<span id="sampling-pinv"></span><h1>Polynomial interpolation based INVersion of CDF (PINV)<a class="headerlink" href="#polynomial-interpolation-based-inversion-of-cdf-pinv" title="Permalink to this heading">#</a></h1>
<ul class="simple">
<li><p>Required: PDF</p></li>
<li><p>Optional: CDF, mode, center</p></li>
<li><p>Speed:</p>
<ul>
<li><p>Set-up: (very) slow</p></li>
<li><p>Sampling: (very) fast</p></li>
</ul>
</li>
</ul>
<p>Polynomial interpolation based INVersion of CDF (PINV) is an inversion method
that only requires the density function to sample from a distribution. It is
based on Polynomial interpolation of the PPF and Gauss-Lobatto integration
of the PDF. It provides control over the interpolation error and integration
error. Its primary purpose is to provide very fast sampling which is nearly
the same for any given distribution at the cost of moderate to slow setup
time. It is the fastest known inversion method for the fixed-parameter case.</p>
<p>The inversion method is the simplest and most flexible to sample nonuniform
random variates. For a target distribution with CDF <span class="math notranslate nohighlight">\(F\)</span> and a uniform
random variate <span class="math notranslate nohighlight">\(U\)</span> sampled from <span class="math notranslate nohighlight">\(\text{Uniform}(0, 1)\)</span>, a random
variate X is generated by transforming the uniform random variate <span class="math notranslate nohighlight">\(U\)</span>
using the PPF (inverse CDF) of the distribution:</p>
<div class="math notranslate nohighlight">
\[X = F^{-1}(U)\]</div>
<p>This method is suitable for stochastic simulations because of its advantages.
Some of the most attractive are:</p>
<ul class="simple">
<li><p>It preserves the structural properties of the uniform random number sampler.</p></li>
<li><p>Transforms a uniform random variate <span class="math notranslate nohighlight">\(U\)</span> one-to-one into non-uniform
random variates <span class="math notranslate nohighlight">\(X\)</span>.</p></li>
<li><p>Easy and efficient sampling from truncated distributions.</p></li>
</ul>
<p>Unfortunately, the PPF is rarely available in closed form or too slow when
available. For many distributions, the CDF is also not easy to obtain. This
method addresses both the shortcomings. The user only has to provide the PDF
and optionally a point near the mode (called “center”) together with the size
of the maximal acceptable error. It uses a combination of an adaptive and a
simple Gauss-Lobatto quadrature to obtain the CDF and Newton’s interpolation
to obtain the PPF. The method is not exact, as it only produces random
variates of the approximated distribution. Nevertheless, the maximal tolerated
approximation error can be set close to the machine precision. The concept of
u-error is used to measure and control the error. It is defined as:</p>
<div class="math notranslate nohighlight">
\[\epsilon_{u}(u) = | u - F\left(F^{-1}_{a}(u)\right) |\]</div>
<p>where <span class="math notranslate nohighlight">\(u \in (0, 1)\)</span> is a quantile where we want to measure the error
and <span class="math notranslate nohighlight">\(F^{-1}_a\)</span> is the approximated PPF of the given distribution.</p>
<p>The maximal u-error is the criterion for approximation errors when calculating
the CDF and PPF numerically. The maximal tolerated u-error of an algorithm is
called the u-resolution of the algorithm and denoted by <span class="math notranslate nohighlight">\(\epsilon_{u}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\sup_{u \in (0,1)} | u - F\left(F^{-1}_{a}(u)\right) | \le \epsilon_{u}\]</div>
<p>The main advantage of the u-error is that it can be easily computed if the CDF
is available. We refer to <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> for a more detailed discussion.</p>
<p>Also, the method only works for bounded distributions. In case of infinite
tails, the ends of the tails are cut off such that the area under them is
less than or equal to <span class="math notranslate nohighlight">\(0.05\epsilon_{u}\)</span>.</p>
<p>There are some restrictions for the given distribution:</p>
<ul class="simple">
<li><p>The support of the distribution (i.e., the region where the PDF is strictly
positive) must be connected. In practice this means, that the region where
PDF is “not too small” must be connected. Unimodal densities satisfy this
condition. If this condition is violated then the domain of the distribution
might be truncated.</p></li>
<li><p>When the PDF is integrated numerically, then the given PDF must be
continuous and should be smooth.</p></li>
<li><p>The PDF must be bounded.</p></li>
<li><p>The algorithm has problems when the distribution has heavy tails (as then
the inverse CDF becomes very steep at 0 or 1) and the requested u-resolution
is very small. E.g., the Cauchy distribution is likely to show this problem
when the requested u-resolution is less than 1.e-12.</p></li>
</ul>
<p>Following four steps are carried out by the algorithm during setup:</p>
<ul class="simple">
<li><p>Computing the end points of the distribution: If a finite support is given,
this step is skipped. Otherwise, the ends of the tails are cut off such that
the area under them is less than or equal to <span class="math notranslate nohighlight">\(0.05\epsilon_{u}\)</span>.</p></li>
<li><p>The domain is divided into subintervals to compute the CDF and PPF.</p></li>
<li><p>The CDF is computed using Gauss-Lobatto quadrature such that the integration
error is at most <span class="math notranslate nohighlight">\(0.05I_{0}\epsilon_{u}\)</span> where <span class="math notranslate nohighlight">\(I_{0}\)</span> is
approximately the total area under the PDF.</p></li>
<li><p>The PPF is computed using Newton’s interpolating formula with maximum
interpolation error <span class="math notranslate nohighlight">\(0.9\epsilon_{u}\)</span>.</p></li>
</ul>
<p>To initialize the generator to sample from a standard normal distribution, do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats.sampling</span> <span class="kn">import</span> <span class="n">NumericalInversePolynomial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">StandardNormal</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">StandardNormal</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">NumericalInversePolynomial</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">urng</span><span class="p">)</span>
</pre></div>
</div>
<p>The generator has been setup and we can start sampling from our distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span><span class="o">.</span><span class="n">rvs</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[-1.52449963,  1.31933688,  2.05884468],</span>
<span class="go">       [ 0.48883931,  0.15207903, -0.02150773],</span>
<span class="go">       [ 1.11486463,  1.95449597, -0.30724928],</span>
<span class="go">       [ 0.9854643 ,  0.29867424,  0.7560304 ],</span>
<span class="go">       [-0.61776203,  0.16033378, -1.00933003]])</span>
</pre></div>
</div>
<p>We can look at the histogram of the random variates to check how well they fit
our distribution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats.sampling</span> <span class="kn">import</span> <span class="n">NumericalInversePolynomial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">StandardNormal</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">StandardNormal</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">NumericalInversePolynomial</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">urng</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rvs</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">rvs</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">rvs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="s2">&quot;r-&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">rvs</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;rvs&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;PDF(x)&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Samples drawn using PINV method.&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="&quot; &quot;" class="plot-directive" src="../../_images/sampling_pinv-1.png" />
</figure>
<p>The maximum tolerated error (i.e. u-resolution) can be changed by passing the
<code class="docutils literal notranslate"><span class="pre">u_resolution</span></code> keyword during initialization:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">NumericalInversePolynomial</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">u_resolution</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">random_state</span><span class="o">=</span><span class="n">urng</span><span class="p">)</span>
</pre></div>
</div>
<p>This leads to a more accurate approximation of the PPF and the
generated RVs follow the exact distribution more closely. Although, note
that it comes at the cost of an expensive setup.</p>
<p>The setup time mainly depends on the number of times the PDF is evaluated.
It is more costly for PDFs that are difficult to evaluate. Note that we can
ignore the normalization constant to speed up the evaluations of the PDF.
PDF evaluations increase during setup for small values of <code class="docutils literal notranslate"><span class="pre">u_resolution</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats.sampling</span> <span class="kn">import</span> <span class="n">NumericalInversePolynomial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">StandardNormal</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">StandardNormal</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># u_resolution = 10^-8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; less PDF evaluations required</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; faster setup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">NumericalInversePolynomial</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">u_resolution</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">random_state</span><span class="o">=</span><span class="n">urng</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span><span class="o">.</span><span class="n">callbacks</span>
<span class="go">4095</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># reset the number of callbacks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># u_resolution = 10^-10 (default)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; more PDF evaluations required</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; slow setup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">NumericalInversePolynomial</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">u_resolution</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">random_state</span><span class="o">=</span><span class="n">urng</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span><span class="o">.</span><span class="n">callbacks</span>
<span class="go">11454</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># reset the number of callbacks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># u_resolution = 10^-12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; lots of PDF evaluations required</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># =&gt; very slow setup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">NumericalInversePolynomial</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">u_resolution</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">random_state</span><span class="o">=</span><span class="n">urng</span><span class="p">)</span>
<span class="go">13902</span>
</pre></div>
</div>
<p>As we can see, the number of PDF evaluations required is very high and a
fast PDF is critical to the algorithm. Though, this helps reduce the number
of subintervals required to achieve the error goal which saves memory and
makes sampling fast. <a class="reference internal" href="../../reference/generated/scipy.stats.sampling.NumericalInverseHermite.html#scipy.stats.sampling.NumericalInverseHermite" title="scipy.stats.sampling.NumericalInverseHermite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NumericalInverseHermite</span></code></a> is a similar inversion method
that inverts the CDF based on Hermite interpolation and provides control
over the maximum tolerated error via u-resolution. But it makes use of a lot
more intervals compared to <a class="reference internal" href="../../reference/generated/scipy.stats.sampling.NumericalInversePolynomial.html#scipy.stats.sampling.NumericalInversePolynomial" title="scipy.stats.sampling.NumericalInversePolynomial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NumericalInversePolynomial</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats.sampling</span> <span class="kn">import</span> <span class="n">NumericalInverseHermite</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># NumericalInverseHermite accepts a `tol` parameter to set the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># u-resolution of the generator.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng_hermite</span> <span class="o">=</span> <span class="n">NumericalInverseHermite</span><span class="p">(</span><span class="n">norm</span><span class="p">(),</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng_hermite</span><span class="o">.</span><span class="n">intervals</span>
<span class="go">3000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng_poly</span> <span class="o">=</span> <span class="n">NumericalInversePolynomial</span><span class="p">(</span><span class="n">norm</span><span class="p">(),</span> <span class="n">u_resolution</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng_poly</span><span class="o">.</span><span class="n">intervals</span>
<span class="go">252</span>
</pre></div>
</div>
<p>When exact CDF of a distribution is available, one can estimate the u-error
achieved by the algorithm by calling the
<a class="reference internal" href="../../reference/generated/scipy.stats.sampling.NumericalInversePolynomial.u_error.html#scipy.stats.sampling.NumericalInversePolynomial.u_error" title="scipy.stats.sampling.NumericalInversePolynomial.u_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">u_error</span></code></a> method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">ndtr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">StandardNormal</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">ndtr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">StandardNormal</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">NumericalInversePolynomial</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">urng</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span><span class="o">.</span><span class="n">u_error</span><span class="p">(</span><span class="n">sample_size</span><span class="o">=</span><span class="mi">100_000</span><span class="p">)</span>
<span class="go">UError(max_error=8.785949745515609e-11, mean_absolute_error=2.9307548109436816e-11)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../reference/generated/scipy.stats.sampling.NumericalInversePolynomial.u_error.html#scipy.stats.sampling.NumericalInversePolynomial.u_error" title="scipy.stats.sampling.NumericalInversePolynomial.u_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">u_error</span></code></a> runs a monte carlo simulation with
a given number of samples to estimate the u-error. In the above example,
100,000 samples are used by the simulation to approximate the u-error. It
returns the maximum u-error (<code class="docutils literal notranslate"><span class="pre">max_error</span></code>) and the mean absolute u-error
(<code class="docutils literal notranslate"><span class="pre">mean_absolute_error</span></code>) in a <code class="docutils literal notranslate"><span class="pre">UError</span></code> namedtuple. As we can see,
<code class="docutils literal notranslate"><span class="pre">max_error</span></code> is below the default <code class="docutils literal notranslate"><span class="pre">u_resolution</span></code> (<code class="docutils literal notranslate"><span class="pre">1e-10</span></code>).</p>
<p>It is also possible to evaluate the PPF of the given distribution once the
generator is initialized:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.975</span><span class="p">)</span>
<span class="go">1.959963985701268</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.975</span><span class="p">)</span>
<span class="go">1.959963984540054</span>
</pre></div>
</div>
<p>We can use this, for example, to check the maximum and mean absolute u-error:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1_000_000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">dist</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">u</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_errors</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">8.78600525666684e-11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_errors</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">2.9321444940323206e-11</span>
</pre></div>
</div>
<p>The approximate PPF method provided by the generator is much faster to
evaluate than the exact PPF of the distribution.</p>
<p>During setup, a table of CDF points is stored that can be used to approximate the
CDF once the generator has been created:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="mf">1.959963984540054</span><span class="p">)</span>
<span class="go">0.9750000000042454</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="mf">1.959963984540054</span><span class="p">)</span>
<span class="go">0.975</span>
</pre></div>
</div>
<p>We can use this to check if the integration error while computing the CDF
exceeds <span class="math notranslate nohighlight">\(0.05I_{0}\epsilon_{u}\)</span>. Here <span class="math notranslate nohighlight">\(I_0\)</span> is
<span class="math notranslate nohighlight">\(\sqrt{2\pi}\)</span> (the normalization constant for the standard normal
distribution):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">100_000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">rng</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_error</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">4.506062190046123e-12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_integration_error</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">I0</span> <span class="o">*</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_error</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">max_integration_error</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The CDF table computed during setup is used to evaluate the CDF and only some
further fine-tuning is required. This reduces the calls to the PDF but as the
fine-tuning step uses the simple Gauss-Lobatto quadrature, the PDF is called
several times, slowing down the computation.</p>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Derflinger, Gerhard, Wolfgang Hörmann, and Josef Leydold. “Random variate
generation by numerical inversion when only the density is known.” ACM
Transactions on Modeling and Computer Simulation (TOMACS) 20.4 (2010): 1-25.</p>
</aside>
</aside>
</section>
</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="sampling_dau.html" title="previous page">
      <i class="fas fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">Discrete Alias Urn (DAU)</p>
      </div>
  </a>
  <a class='right-next' id="next-link" href="sampling_dgt.html" title="next page">
  <div class="prev-next-info">
      <p class="prev-next-subtitle">next</p>
      <p class="prev-next-title">Discrete Guide Table (DGT)</p>
  </div>
  <i class="fas fa-angle-right"></i>
  </a>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2008-2023, The SciPy community.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>