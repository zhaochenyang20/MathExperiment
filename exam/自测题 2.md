# 1

$H_0:\mu_A \ge 85$，`ttest(a, 85, 'Tail', 'right');`，接受$H_0$

$H_0:\mu_A = \mu_B$，`ttest2(a, b, 'Tail','both');`，接受$H_0$

数据服从正态总体，且相互独立

```python
from scipy.stats import ttest_ind

# 两个独立样本的数据
sample1 = [87, 85, 86, 80, 80]
sample2 = [87, 90, 87, 84]

# 执行t检验
statistic, p_value = ttest_ind(sample1, sample2)

# 打印结果
print("T统计量：", statistic)
print("P值：", p_value)
```

# 2

二、用电压 $V=14 \mathrm{~V}$ 的电池给电容器充电, 电容器上 $t$ 时刻的电压满足:
$$
\nu(t)=V-\left(V-V_0\right) \exp \left(-\frac{t}{\tau}\right),
$$
其中 $V_0$ 是电容器的初始电压, $\tau$ 是充电常数. 试用下列数据确定 $V_0$ 和 $\tau$.
$$
\begin{array}{c|c|c|c|c|c|c}
\hline t / \mathrm{s} & 0.3 & 0.5 & 1.0 & 2.0 & 4.0 & 7.0 \\
\hline v(t) & 5.6873 & 6.1434 & 7.1633 & 8.8626 & 11.0328 & 12.6962 \\
\hline
\end{array}
$$


你用的方法是$()$，结果是 $V_0=();\tau=()$

非线性最小二乘拟合

```
tau = 3.5868762629202906
v0 = 4.971112892906591
```

```python
import numpy as np
from scipy.optimize import curve_fit

# 定义v(t)的函数表达式
def v_func(t, tau, v0):
    return 14 - (14 - v0) * np.exp(-t/tau)

# 加载数据集，假设已经有了一组v(t)与t的数据
t_data = np.array([0.3, 0.5, 1.0, 2.0, 4.0, 7.0])
v_data = np.array([5.6873, 6.1434, 7.1633, 8.8626, 11.0328, 12.6962])

# 使用curve_fit函数进行线性回归拟合
popt, pcov = curve_fit(v_func, t_data, v_data)

# popt包含了拟合出的tau和v0的值
tau = popt[0]
v0 = popt[1]

print("tau =", tau)
print("v0 =", v0)
```

或者：

```python
import numpy as np
from scipy.optimize import least_squares

list_t = np.array([0.3, 0.5, 1.0, 2.0, 4.0, 7.0])
list_ct = np.array([5.6873, 6.1434, 7.1633, 8.8626, 11.0328, 12.6962])


def objective(x):
    v0 = x[0]
    tao = x[1]
    v = 14
    F = np.zeros(len(list_t))
    for i in range(len(list_t)):
        t = list_t[i]
        ct = list_ct[i]
        F[i] = ct - (v - (v - v0) * np.exp(- t / tao))
    return F

def compute_loss(x):
    v0 = x[0]
    tao = x[1]
    v = 14
    loss_list =  (v - (v - v0) * np.exp(- list_t / tao))
    return np.sum((loss_list - list_ct) ** 2)


x0 = [0, 0]
x0 = [1, 1]
#! x0 的选取影响很大，但是 tau 确实不该取 0
res = least_squares(objective, x0)
print(res.x)
```

实际上还可以用线性最小二乘法：

线性最小二乘法可以用来拟合非线性函数，将其转化为一个线性的问题。对于这个问题，我们可以将 $\nu(t)$ 取对数，得到：
$$
\ln \left(V-\nu(t)\right)=\ln \left(V-V_0\right)-\frac{t}{\tau}
$$
这是一个关于 $\ln \left(V-V_0\right)$ 和 $1/\tau$ 的线性方程，可以使用线性最小二乘法进行拟合。

```python
import numpy as np
from scipy.optimize import curve_fit

t_data = np.array([0.3, 0.5, 1.0, 2.0, 4.0, 7.0])
v_data = np.array([5.6873, 6.1434, 7.1633, 8.8626, 11.0328, 12.6962])

log_v_data = np.log(14 - v_data)

def v_func(t, tau, v0):
    return np.log(14-v0) - t / tau

popt, pcov = curve_fit(v_func, t_data, log_v_data, p0=[1, 0])

tau = popt[0]
v0 = popt[1]


# 模板二

import numpy as np
from scipy.optimize import least_squares

list_t = np.array([0.3, 0.5, 1.0, 2.0, 4.0, 7.0])
v_data = np.array([5.6873, 6.1434, 7.1633, 8.8626, 11.0328, 12.6962])

def objective(x):
    v0 = x[0]
    tao = x[1]
    v = 14
    F = np.zeros(len(list_t))
    for i in range(len(list_t)):
        t = list_t[i]
        vt = v_data[i]
        F[i] = np.log(v -vt) - np.log(v - v0) + t / tao
    return F

x0 = [1, 1]
#! x0 的选取影响很大，但是 tau 确实不该取 0
res = least_squares(objective, x0)
print(res.x)
```

# 3

(1)
$$
t \le 40: 
x'' = \frac{30000 - 0.4x'^2}{900-15t}-g \\
x(0) = x'(0) = 0 \\
t > 40:x'' = \frac{- 0.4x'^2}{300}-g
$$
(2)

关闭前：

```
x: 8322.860629925617
x': 258.9846006420448
x'': 0.7693021737074002
```

关闭后：
```
x: 9191.009052730167 
t: 50.92
```

```python
import numpy as np
from scipy.integrate import odeint

def dxv_dt(input_list, t):
    x, v = input_list
    dx_dt = v
    dv_dt = ((30000 - 0.4 * v ** 2) / (900 - 15 * t)) - 9.8
    return dx_dt, dv_dt

# 初始条件
y_a = [0, 0]

# 自变量范围
x = np.linspace(0, 40, 1000)

# 求解微分方程
y = odeint(dxv_dt, y_a, x)

# 输出结果
x, v = y[-1]
dv_dt = ((30000 - 0.4 * v ** 2) / (900 - 15 * 40)) - 9.8
```

```python
import numpy as np
from scipy.integrate import odeint

def dxv_dt(input_list, t):
    x, v = input_list
    dx_dt = v
    dv_dt = (- 0.4 * v ** 2 / 300) - 9.8
    return dx_dt, dv_dt

# 初始条件
y_a = [8322.860629925617, 258.9846006420448]

# 自变量范围
x = np.linspace(40, 100, 10000)

# 求解微分方程
y = odeint(dxv_dt, y_a, x)

x = y[:, 0]
v = y[:, 1]
for i in range(len(v)):
    if v[i] < 0 :
        print(x[i-1], (i-1) / 10000 * 60 + 40, v[i-1], v[i])
        break
```

# 4

(3) 

```
x(1): [6000.  300.  500.  650.  700.]
在第 3 年时出现负值： [1020. 2120. 2460. -142.  100.]
因此最多持续2年
```

(4)

```
不动点为： [2000. 1000.  500.  250.  100.]
```

(5)

```
迭代的系数矩阵L的谱半径为： (1.298189908789245+0j)
因此收敛：False
```

```python
import numpy as np
L = np.array([[0, 0, 2, 4, 0],
              [0.7, 0, 0, 0, 0],
              [0, 0.7, 0, 0, 0],
              [0, 0, 0.8, 0, 0],
              [0, 0, 0, 0.8, 0]])
#! 注意 h 向量遵循的逻辑是成熟再收割
#! 比如 x5(t+1) = x4(t) * (1 - d4) - h4
h = np.array([0, 400, 200, 150, 100])
x_0 = np.array([1000]*5)

# (3)
x_new = L@x_0.T-h.T
print("x(1):", x_new)

cnt = 1;
while(np.sum(x_new < 0) == 0):
  # x_new < 0 是一个 bool 矩阵
    x_new = L@x_new.T-h.T
    cnt += 1
print("在第", cnt,"年时出现负值：", x_new)
print(f"因此最多持续{cnt-1}年")
print("")

#(4)
print("不动点为：",np.linalg.inv(L-np.eye(5))@h.T)
print("")

#(5)
abs_eigen_values = np.max(np.linalg.eigvals(L))
print("迭代的系数矩阵L的谱半径为：",abs_eigen_values)
print(f"因此收敛：{abs_eigen_values < 1}")
```

